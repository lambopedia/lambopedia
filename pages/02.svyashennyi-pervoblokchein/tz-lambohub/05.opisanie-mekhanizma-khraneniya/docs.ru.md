---
title: 'Описание механизма хранения'
---

## Распределённая хеш-таблица
Сейчас в мире передовым алгоритмом децентрализованного хранения информации считается [распределённая хэш-таблица (DHT)](https://ru.wikipedia.org/wiki/Распределённая_хеш-таблица). Поддержка данного алгоритма реализована в [популярных торрент-клиентах](https://ru.wikibooks.org/wiki/BitTorrent/DHT) (см. [Kademlia](https://habr.com/post/107342/)). По сути - это реализация [индекса (БД)](https://ru.wikipedia.org/wiki/Индекс_(базы_данных)), где вместо строк - узлы. 
Можно ещё ознакомиться с [этим](https://ru.wikipedia.org/wiki/Быстрая_сортировка) и [этим](https://ru.wikipedia.org/wiki/Алгоритм_сортировки).
Рассмотрим недостатки данного алгоритма. Для простоты понимания примера прибегнем к упрощению: путь хэш - это будет сразу беззнаковое целое (отбросим пока операцию XOR).  
Пусть есть узел с ID = 1. В него записан файл, хэш имени которого = 100. Файл в него записан в соответствии с правилом о максимальной схожести.  

[nom]
[Файл1]->[ИмяФайла1]
[ИмяФайла1]->[Хэш100]
[Хэш100]->[Узел1]
[/nom]

Пусть появляется узлы с ID = 30, 60, 90, 120. В соответствии с правилом алгоритма файл, хэш имени которого = 100, необходимо искать в узле 90. Но файл находится в узле 1.

[nom]
[Узел1] - [Файл1]
[Узел30]
[Узел60]
[Узел90] --> [Хэш100]
[Хэш100] --> [ИмяФайла1]
[ИмяФайла1] --> [Файл]
[Узел120]
[/nom]

Получается, что чтобы файл не потерялся, его необходимо переносить на полее подходящий узел, при появлении такового.  
  
Важно помнить, что хэш не является уникальным идентификатором, то есть не исключает совпадения значения при подаче на вход разных данных. При увеличении разрядности хэша, уменьшается вероятность совпадения. Вероятность совпадения равна нулю, только когда длина хэша равна или больше длине подаваемых данных. Это означает, что необходимо всё-равно добавлять к сохраняемым данным дополнительную информацию, для идентификации файла и его владельца.  
Случайная генерация проста и помогает равномерно распределить идентификаторы узлов по всему пространству значений. Однако этот подход не может помочь в случае, когда возникла высокая нагрузка по объёму записываемых или считываемых данных на один конкретный узел, или группу узлов.

Наконец распределённая хэш-таблица ничем не помогает в случае, если мы хотим хранить копию файлов не только на одном носителе, а на настраиваемом количестве носителей.  
  
Принимая во внимание вышесказанное, предлагаю следующее.  

## Распределённая таблица адресов
### Идея
Использовать не хэш, а именно уникальный идентификатор, то есть целое число и систему адрессации оптимизированную под наши нужды. Файлы нарезать на блоки по 1МБ каждый. Сразу сгруппировать узлы для хранения нужного уровня надёжности. Блоки нужны для распараллеливания.   
Каждый адрес будет состоять из:
* ИД аккаунта, 32 бит;
* ИД блока в аккаунте, 64 бит;
* ИД носителя, 61 бит;
* Уровень надёжности, 3 бит.

ИД аккаунта и ИД блока в аккаунте - чтобы находить нужные данные на носителе. 32 бита обеспечивает 4,3 млрд. клиентских аккаунтов. При необходимости можно будет расширить. 64-битный ИД блока в аккаунте позволяет хранить до `18,4 * 10^12` ТБ в одном аккаунте клиента.
О последнем расскажем подробнее. Уровень надёжности - это параметр, показывающий системе с одной стороны на скольких носителях должен храниться файл. С другой стороны этот параметр указывает на диапазон идентификаторов носителей, на которых данный файл нужно искать.  

```
Число носителей = 2^(3 + уровень_надёжности * 2)  
Если уровень надёжности = 0, то число носителей = 8.
Если уровень надёжности = 7, то число носителей = 131072.
```

ИД носителя 63-битный, но в адресе составляет 61 бит. Например, если в адресе указан ИД носителя = 8 (..01000) и уровень надёжности 0, то это означает все идентификаторы от 8-го до 15-го: 8, 9, 10, 11, 12, 13, 14, 15.

[nom]
[Группа|Адрес: 8|Уровень надёжности: 0]
[Группа]->[Узел8]
[Группа]->[Узел9]
[Группа]->[Узел10]
[Группа]->[Узел11]
[Группа]->[Узел12]
[Группа]->[Узел13]
[Группа]->[Узел14]
[Группа]->[Узел15]
[/nom]

### Аккаунт
Пользователь после регистрации получает число - номер аккаунта. В момент регистрации в системе создаётся и записывается файл. Перед записью файл шифруется паролем пользователя. В файле хранится информация о структуре диска, имена и расположение созданных каталогов, имена и расположение файлов, адреса их блоков и так далее.

### Запись файла
Файл разбивается на блоки (по 64кБ). Каждый блок записываем отдельно. Если это файл аккаунта, то разбиваем начиная с конца, записываем сначала последний блок, его адрес помещаем в конец предыдущего и так до первого блока.

### Чтение файла
Достаём из файла аккаунта перечень адресов блоков. По каждому адресу достаём 

