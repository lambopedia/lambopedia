---
title: 'Описание механизма хранения'
---

## Распределённая хеш-таблица
Сейчас в мире передовым алгоритмом децентрализованного хранения информации считается [распределённая хэш-таблица (DHT)](https://ru.wikipedia.org/wiki/Распределённая_хеш-таблица). Поддержка данного алгоритма реализована в [популярных торрент-клиентах](https://ru.wikibooks.org/wiki/BitTorrent/DHT) (см. [Kademlia](https://habr.com/post/107342/)). По сути - это реализация [индекса (БД)](https://ru.wikipedia.org/wiki/Индекс_(базы_данных)), где вместо строк - узлы. 
Можно ещё ознакомиться с [этим](https://ru.wikipedia.org/wiki/Быстрая_сортировка) и [этим](https://ru.wikipedia.org/wiki/Алгоритм_сортировки).
Рассмотрим недостатки данного алгоритма. Для простоты понимания примера прибегнем к упрощению: путь хэш - это будет сразу беззнаковое целое (отбросим пока операцию XOR).  
Пусть есть узел с ID = 1. В него записан файл, хэш имени которого = 100. Файл в него записан в соответствии с правилом о максимальной схожести.  

[nom]
[Файл1]->[ИмяФайла1]
[ИмяФайла1]->[Хэш100]
[Хэш100]->[Узел1]
[/nom]

Пусть появляется узлы с ID = 30, 60, 90, 120. В соответствии с правилом алгоритма файл, хэш имени которого = 100, необходимо искать в узле 90. Но файл находится в узле 1.

[nom]
[Узел1] - [Файл1]
[Узел30]
[Узел60]
[Узел90] --> [Хэш100]
[Хэш100] --> [ИмяФайла1]
[ИмяФайла1] --> [Файл]
[Узел120]
[/nom]

Получается, что чтобы файл не потерялся, его необходимо переносить на полее подходящий узел, при появлении такового.  
  
Важно помнить, что хэш не является уникальным идентификатором, то есть не исключает совпадения значения при подаче на вход разных данных. При увеличении разрядности хэша, уменьшается вероятность совпадения. Вероятность совпадения равна нулю, только когда длина хэша равна или больше длине подаваемых данных. Это означает, что необходимо всё-равно добавлять к сохраняемым данным дополнительную информацию, для идентификации файла и его владельца.  
Случайная генерация проста и помогает равномерно распределить идентификаторы узлов по всему пространству значений. Однако этот подход не может помочь в случае, когда возникла высокая нагрузка по объёму записываемых или считываемых данных на один конкретный узел, или группу узлов.

Наконец распределённая хэш-таблица ничем не помогает в случае, если мы хотим хранить копию файлов не только на одном носителе, а на настраиваемом количестве носителей.  
  
Принимая во внимание вышесказанное, предлагаю следующее.  

## Распределённая таблица адресов
### Идея
Оставить хэши в покое и вернуться к первоначальной методике поиска ресурсов по ключам в P2P-сетях. А именно использовать настоящий уникальный идентификатор. То есть целое число и систему адрессации, оптимизированную под наши нужды. Файлы нарезать на блоки по 1МБ каждый. Сразу сгруппировать узлы для хранения нужного уровня надёжности. Блоки нужны для распараллеливания.   
Каждый адрес будет состоять из:
* ИД аккаунта, 32 бит;
* ИД блока в аккаунте, 32 бит;
* ИД носителя, 61 бит;
* Уровень надёжности, 3 бит.
  
ИД аккаунта и ИД блока в аккаунте - это чтобы находить нужные данные на носителе. 32 бита обеспечивает 4,3 млрд. клиентских аккаунтов. При необходимости можно будет расширить за счёт ИД блока.  
32-битный ИД блока в аккаунте позволяет хранить 4,3 млрд. блоков в одном аккаунте (до 4294ТБ). Файлы могут быть двух типов:
* когда информация о всех блоках файла хранится в аккаунте (позволяет распарралеливать запись и чтение);
* когда в аккаунте хранится информация только о первом блоке и файл представляет из себя цепочку блоков.  

Уровень надёжности - это параметр, показывающий системе с одной стороны на скольких носителях должен храниться файл. С другой стороны этот параметр указывает на диапазон идентификаторов носителей, на которых данный файл нужно искать.  

```
Число носителей = 2^(3 + уровень_надёжности * 2)  
Если уровень надёжности = 0, то число носителей = 8.
Если уровень надёжности = 7, то число носителей = 131072.
```

ИД носителя 63-битный, но в адресе составляет 61 бит. Например, если в адресе указан ИД носителя = 8 (..01000) и уровень надёжности 0, то это означает все идентификаторы от 8-го до 15-го: 8, 9, 10, 11, 12, 13, 14, 15.

[nom]
[Группа|Адрес: 8|Уровень надёжности: 0]
[Группа]->[Узел8]
[Группа]->[Узел9]
[Группа]->[Узел10]
[Группа]->[Узел11]
[Группа]->[Узел12]
[Группа]->[Узел13]
[Группа]->[Узел14]
[Группа]->[Узел15]
[/nom]

### Аккаунт
Пользователь после регистрации получает число - номер аккаунта. В момент регистрации в системе создаётся и записывается файл. Перед записью файл шифруется паролем пользователя. В файле хранится информация о структуре диска, имена и расположение созданных каталогов, имена и расположение файлов, адреса их блоков и так далее.

### Запись файла
Файл разбивается на блоки (по 1МБ). Каждый блок записываем отдельно. Если это файл аккаунта, то разбиваем начиная с конца, записываем сначала последний блок, его адрес помещаем в конец предыдущего и так до первого блока.

### Чтение файла
1. Достаём из файла аккаунта перечень адресов блоков. 
2. По каждому блоку из адреса достаём ИД носителей. 
3. Отправляем запрос на любой узел.
4. _Каждый узел хранит таблицу с координатами ближних и дальних узлов. Здесь как в алгоритме быстрой сортировки или в хэш-таблицах - передаём координаты наиболее подходящего узла._
5. Повторяем 4, пока нужный узел не будет найден.
6. Внутри узла находим нужный блок, получаем список других узлов, на которых лежит этот блок и скачиваем с наименее загруженного узла из списка.

### Узел подключился

### Узел отключился
Раз в час (период требуется определить эмпирически) каждый узел отправляет запрос по известным ему узлам. В ответе должна содержаться следующая информация:
* актуальные координаты (IP адрес и порт);
* количество свободного места.
Запрашивающий узел обновляет данные в своей таблице, обновляет метку времени.

|  Узел  |           IP            |    Порт     | Свободное место, МБ |        Обновлено         |
| -------- | --------------------- | ------------ | ------------------------------: | --------------------------- |
| 12345 |  80.160.80.160  |   37905   |                          140045 | 2019.01.07 15:34:01 |
| 12346 |  80.160.80.161  |   37905   |                            80045 | 2019.01.07 15:34:02 |

Если от узла нет ответа, то необходимо определить для каждого уровня надёжности, сколько узлов неактивно в соответствующей группе.

| Узлов в группе осталось менее, % | Ждём появления пропавшего узла, сек |
| ------------------------------------------------ | ------------------------------------------------------- |
|   100  |  604800  |
|  87,5  |  302400  |
|   75    |  151200  |
|   62,5 |  75600    |
|   50    |  32400    |
|   37,5 |  10800    |
|   25    |   3600     |
|   12,5 |  300        |