---
title: 'Описание механизма хранения'
---

## Распределённая хеш-таблица
Сейчас в мире передовым алгоритмом децентрализованного хранения информации считается [распределённая хэш-таблица (DHT)](https://ru.wikipedia.org/wiki/Распределённая_хеш-таблица). Поддержка данного алгоритма реализована в [популярных торрент-клиентах](https://ru.wikibooks.org/wiki/BitTorrent/DHT) (см. [Kademlia](https://habr.com/post/107342/)). По сути - это реализация [индекса (БД)](https://ru.wikipedia.org/wiki/Индекс_(базы_данных)), где вместо строк - узлы. 
Можно ещё ознакомиться с [этим](https://ru.wikipedia.org/wiki/Быстрая_сортировка) и [этим](https://ru.wikipedia.org/wiki/Алгоритм_сортировки).
Рассмотрим недостатки данного алгоритма. Для простоты понимания примера прибегнем к упрощению: путь хэш - это будет сразу беззнаковое целое (отбросим пока операцию XOR).  
Пусть есть узел с ID = 1. В него записан файл, хэш имени которого = 100. Файл в него записан в соответствии с правилом о максимальной схожести.  

[nom]
[Файл1]->[ИмяФайла1]
[ИмяФайла1]->[Хэш100]
[Хэш100]->[Узел1]
[/nom]

Пусть появляется узлы с ID = 30, 60, 90, 120. В соответствии с правилом алгоритма файл, хэш имени которого = 100, необходимо искать в узле 90. Но файл находится в узле 1.

[nom]
[Узел1] - [Файл1]
[Узел30]
[Узел60]
[Узел90] --> [Хэш100]
[Хэш100] --> [ИмяФайла1]
[ИмяФайла1] --> [Файл]
[Узел120]
[/nom]

Получается, что чтобы файл не потерялся, его необходимо переносить на полее подходящий узел, при появлении такового.  
  
Важно помнить, что хэш не является уникальным идентификатором, то есть не исключает совпадения значения при подаче на вход разных данных. При увеличении разрядности хэша, уменьшается вероятность совпадения. Вероятность совпадения равна нулю, только когда длина хэша равна или больше длине подаваемых данных. Это означает, что необходимо всё-равно добавлять к сохраняемым данным дополнительную информацию, для идентификации файла и его владельца.  
Случайная генерация проста и помогает равномерно распределить идентификаторы узлов по всему пространству значений. Однако этот подход не может помочь в случае, когда возникла высокая нагрузка по объёму записываемых или считываемых данных на один конкретный узел, или группу узлов.

Наконец распределённая хэш-таблица ничем не помогает в случае, если мы хотим хранить копию файлов не только на одном носителе, а на настраиваемом количестве носителей.  
  
Принимая во внимание вышесказанное, предлагаю следующее.  

## Распределённая таблица адресов
### Замысел
Использовать не хэш, а именно уникальный идентификатор, то есть целое число и систему адрессации оптимизированную под наши нужды.  
Каждый адрес будет состоять из:
* ИД аккаунта, 32 бит;
* ИД блока в аккаунте, 64 бит;
* ИД носителя, 60 бит;
* Уровень надёжности, 4 бит.

О последнем расскажем подробнее. Уровень надёжности - это параметр, показывающий системе с одной стороны на скольких носителях должен храниться файл. С другой стороны этот параметр указывает на диапазон идентификаторов носителей, на которых данный файл можно искать.  

```
Число носителей = 2^(2 + уровень_надёжности)
```

ИД носителя 62-битный, но в адресе составляет 60 бит. Например, если уровень надёжности указанный в адресе = 0, тогда число носителей, согласно формуле = 4. Если в адресе указан ИД носителя = 4 (..00100), то это означает все идентификаторы от 4-ки до 7-ки: 4, 5, 6, 7.  

### Аккаунт
Пользователь после регистрации получает число - номер аккаунта. В момент регистрации в системе создаётся и записывается файл. Перед записью файл шифруется паролем пользователя. В файле хранится информация о структуре диска, имена и расположение созданных каталогов, имена и расположение файлов, адреса их блоков и так далее.

### Запись файла
Файл разбивается на блоки (по 64кБ). Каждый блок записываем отдельно. Если это файл аккаунта, то разбиваем начиная с конца, записываем сначала последний блок, его адрес помещаем в конец предыдущего и так до первого блока.

### Чтение файла
Достаём из файла аккаунта перечень адресов блоков. 

